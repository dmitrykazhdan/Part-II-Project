
- Fixup cardinality generation 

- Fixup cardinality lower bound handling. Avoid using string conversion. Incorporate within rule.

- Group "current variable" and "current group" instantiations into one object.

- Implement restriction checking.
	
- Implement exception rules.

- Implement generating rules.

- Add a check for disjointness of data ranges, as given in the rules (e.g. Dr0 & Dr1 are disjoint)


- Fixup excessive type-casting in pattern matching.

- Fixup "GroupExpression" pattern for equivalent classes and for disjoint classes.

- Add restrictions to rules.


- In "ProcessOntology", add a timeout for the "gen.getExplanations(entailment, 4);" step.

- In "GenerateTrees" add a timeout for the tree generator.

- In the "ProofTreeGenerator" class, in the "getLaconicJustifications" method, add a timeout step
when computing laconic justifications.



- Potentially: add restrictions between free variables, contained in the ruleString constructor.

- Throw exception if class expression is non-deterministic.

- Have a "Matcher" interface, with "RuleString" and "Exception" implementing it.

- For rules, all "group expressions" are only atomic ones, with no inner patterns.
Thus, have simple groups for rules, and more complex groups for exceptions, with inner patterns.
However, keep in mind that for exceptions you only need to pattern match, not generate.

- Perhaps have two types of "group expression" - flat and complex.

- Potential thought: have multiple types of "group expressions", including "subset-superset", and also
"previous - new" with a defined transformation mapping "previous" to "new"






Group is:

- Name
- boolean hasBaggage
- ClsExp[] namedPattern


0) If has no baggage, check that number of patterns = number of items in instance.
1) Generate all possible orderings of the group.
2) Attempt to match the given ordering to the pattern.

MATCH:

3) Check subset constraints (if any)


GENERATE:

3) Generate all possible variants matching the constraint.
