- Implement restriction checking.
	
- Implement exception rules.

- Implement generating rules.

- Have a "simple/atomic" expression group, and a more complex expression group.

- Fixup excessive type-casting in pattern matching.


- In "ProcessOntology", add a timeout for the "gen.getExplanations(entailment, 4);" step.

- In "GenerateTrees" add a timeout for the tree generator.

- In the "ProofTreeGenerator" class, in the "getLaconicJustifications" method, add a timeout step
when computing laconic justifications.




- Have a "Matcher" interface, with "RuleString" and "Exception" implementing it.

- For rules, all "group expressions" are only atomic ones, with no inner patterns.
Thus, have simple groups for rules, and more complex groups for exceptions, with inner patterns.
However, keep in mind that for exceptions you only need to pattern match, not generate.

- Perhaps have two types of "group expression" - flat and complex.

- Potential thought: have multiple types of "group expressions", including "subset-superset", and also
"previous - new" with a defined transformation mapping "previous" to "new"






Group is:

- Name
- boolean hasBaggage
- ClsExp[] namedPattern


0) If has no baggage, check that number of patterns = number of items in instance.
1) Generate all possible orderings of the group.
2) Attempt to match the given ordering to the pattern.

MATCH:

3) Check subset constraints (if any)


GENERATE:

3) Generate all possible variants matching the constraint.
