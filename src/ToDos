- Edge case of rule 52 (and potentially others) if class expressions are equal.

- Add restrictions on exceptions. Allow only a restricted input type.

- Do disjointness of data ranges.

- Implement exception rules.

- Look at cases when intersection/union size = 1. Think about how to handle it.

- Remove repeated code. Cleanup somehow.

- Have a "simple/atomic" expression group, and a more complex expression group.
Matching and generation of class expressions only uses the atomic expression groups.

- What happens if the entailment is already in the laconic justification?
Currently we have a node with the same value, and so we fail.



- In "ProcessOntology", add a timeout for the "gen.getExplanations(entailment, 4);" step.

- In "GenerateTrees" add a timeout for the tree generator.

- In the "ProofTreeGenerator" class, in the "getLaconicJustifications" method, add a timeout step
when computing laconic justifications.




- Have a "Matcher" interface, with "RuleString" and "Exception" implementing it.

- For rules, all "group expressions" are only atomic ones, with no inner patterns.
Thus, have simple groups for rules, and more complex groups for exceptions, with inner patterns.
However, keep in mind that for exceptions you only need to pattern match, not generate.

- Perhaps have two types of "group expression" - flat and complex.

- Potential thought: have multiple types of "group expressions", including "subset-superset", and also
"previous - new" with a defined transformation mapping "previous" to "new"






Group is:

- Name
- boolean hasBaggage
- ClsExp[] namedPattern


0) If has no baggage, check that number of patterns = number of items in instance.
1) Generate all possible orderings of the group.
2) Attempt to match the given ordering to the pattern.

MATCH:

3) Check subset constraints (if any)


GENERATE:

3) Generate all possible variants matching the constraint.
